# 운영체제

## 프로세스와 스레드
- 프로그램(Program)이란?
    - 사전적의미로는 어떤 작업을 위해 실행할 수 있는 파일
- 프로세스(Process)란?
    - 사전적의미로는, 컴퓨터에서 연속적으로 실행되고 있는 프로그램
        - **메모리에 올라와서 실행**되고 있는 프로그램의 인스턴스
        - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
        - 동적인 개념에서는 실행중인 프로그램을 의미한다.
    - 할당받는 시스템자원에는 무엇이 있나?
        - CPU 시간
        - 운영되기 위해서 필요한 메모리 공간
        - Code, Data, Stack, Heap 구조로 되어있는 독립된 **메모리영역**
    - 특징
        - 프로세스는 각각 **독립된 메모리 영역**(Code, Data, Stack, Heap)을 할당받는다.
        - 프로세스당 최소 1개의 스레드(메인스레드)를 가지고 있다.
        - 각 프로세스는 별도의 주소공간에서 실행된다. 다른 프로세스의 데이터에 접근할 수 없다.
        - 다른 프로세스의 자원에 접근하려면 프로세스간 통신(IPC, Inter-Process Communication)을 사용해야한다. 
- 스레드란?
    - 프로세스가 할당받은 자원을 이용하는 실행의 단위
    - 특징
        - 스레드는 프로세스 영역에서 Stack만 따로 할당받고, Code, Data, Heap영역은 공유한다.
        - 스레드는 한 프로세스 내에서 실행되는 **여러**실행의 흐름으로, 프로세스 내의 주소공간이나 자원들을 같은 프로세스 내의 스레드끼리 공유하면서 실행할 수 있다.
        - 같은 프로세스 안에 있는 스레드들은 힙영역을 공유한다. IPC를 사용하지 않는 이상 프로세스는 다른 프로세스의 자원에 접근할 수 없다는 점을 기억하자.
        - 레지스터와 스택은 별도의 영역을 가진다.
        - 한 프로세스가 프로세스 자원을 변경하면 다른 스레드도 변경된 내용을 읽을 수 있다.
            - 하지만 이 때문에 자원의 동기화문제를 고려해야한다는 단점이 있다.
    
## 멀티 프로세스보다 멀티 스레드!
멀티 프로세스는 프로그램을 여러개 켜는 것이고, 멀티 스레드는 하나의 프로그램에서 여러 작업을 해결하는 것이다.<br>
멀티 스레드의 장점에 대해서 알아보자
- 자원의 효율성이 증가된다.
    - 멀티 프로세스로 작업하던 작업을 멀티 스레드로 작업할 경우 생성해야하는 프로세스 자원과 시스템콜이 줄어들기 때문에 자원을 효율적으로 관리할 수 있다.
    - 프로세스간의 Context Switching시에 CPU, 레지스터의 교환 뿐만 아니라 RAM과 CPU 사이의 캐시메모리까지 초기화해야하기 때문에 오버헤드가 크기 때문이다.
- 처리비용, 응답시간의 단축
    - 또한 프로세스 간의 통신(IPC)보다 스레드간의 통신의 비용이 싸게 먹히기 때문에 작업들 간의 통신의 부담이 줄어든다.
        - 스레드는 Stack을 제외한 영역의 메모리를 공유하기 때문이다.
    - 프로세스간에 전환하는 속도보다 스레드간에 전환하는 속도가 더 빠르다.
        - Context Switching시에 스레드는 Stack 영역만 처리하기 때문이다.
- 하지만 멀티 스레드를 사용하게 되면 **동기화 문제**를 주의해야한다.
- 스레드간의 자원공유는 전역변수(데이터 세그먼트)를 이용하므로 상용할 때 충돌이 발생할 수도 있다.
- Thread Safe
    - 멀티스레드 환경에서 여러 스레드가 동시에 같은 공유자원에 접근할 때 의도한 대로 동작하는 것을 말한다.
    - Thread Safe 하게 구현하기 위해서는 공유자원에 접근하는 ciritical section을 동기화 기법으로 제어해주어야한다.
    - 동기화 기법으로는 Mutext나 Semaphore가 있다.
    - Reentrant
        - 어떤 함수가 Reentrant하다는 것은 여러스레드가 동시에 접근해도 항상 같은 실행결과를 보장한다는 의미이다.
        - 이를 만족하기 위해서 해당 서브루틴에서 공유자원을 사용하지 않으면 된다.
            - 정적(전역)변수를 사용하거나 반환하지 않고 함수 호출시에 주어진 매개변수만으로 동작하면 된다.
        - Reentrant하다면 Thread-Safe하지만, Thread-Safe하다고 해서 Reentrant한 것은 아니다.

정리하면
- 멀티 스레드
    - 장점
        - 멀티 프로세스보다 적은 메모리 공간을 차지한다.
        - Context Switching이 빠르다
    - 단점
        - 오류로 인해서 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 문제점이 있다.
- 멀티 프로세스
    - 장점
        - 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점
    - 단점
        - 멀티스레드보다 많은 메모리 공간과 CPU시간을 차지한다.

대상 시스템에 따라서 적합한 동작방식을 선택해야한다.


## 프로세스 동기화

### `Critical Section`
    - 앞의 멀티스레딩의 문제점에서도 보았듯이, 동일한 자원에 동시에 접근하는 작업을 실행하는 **코드 영역**을 `Critical Section`이라 부른다.

### Critical Section Problem(임계 영역문제)
- 프로세스 들이 `Critical Section`을 함께 사용할 수 잇는 프로토콜을 설계해야한다.
- 해결을 위한 기본 조건
    - Mutual Exclusive(상호 배제)
        - 하나의 프로세스가 `Critical Section` 내부에서 시행중이라면, 다른 프로세스들은 그들이 거쳐야하는 `Critical Section`에서 실행될 수 없다.
    - Progress(진행)
        - `Ciritical Section`에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 Ciritcal Section의 진입 후보가 될 수 있다.
    - Bounded Waiting(한정된 대기)
        - 어떤 프로세스가 `Ciritical Section`에 진입 신청 후부터 받아들여질 때까지, 다른 프로세스들이 `Ciritical Section`에 진입하는 횟수는 제한이 있어야한다.

### 동기화 문제 해결책
### Mutex Lock
- 공유자원에 동시에 접근하는 것을 막기 위해서 Ciritical Section에 진입하는 프로세스가 Lock을 획득하고, 나올때 Lock을 방출해서 동시에 접근되지 않도록 하는 방법이다.
- 하지만 다중 처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.
### Semaphore(세마포어)
- Mutex Lock과 마찬가지고 Critical Section에 접근하는 문제를 해결하기 위해서 만든 동기화 도구이다.
- 세마포어에는 Counting/Binary Semaphore 추가지 종류가 있다.
    - 카운팅 세마포어(Counting Semaphore)
        - 세마포어의 개수만큼 스레드가 자원에 접근할 수 있다.
        - 당연히 자원에 접근할 수 있는 수만큼 세마포어 값이 초기화된다.
        - 자원을 사용하면 세마포어가 감소, 방출하면 세마포어가 증가한다.
    - 이진 세마포어(Binary Semaphore)
        - MUTEX라고도 부르며, 상호배제의(Mutext Exclusive)의 머릿글자를 따서 만들어졌다.
        - 이름처럼 0과 1사이의 값만 가능하다. 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해서 사용한다.
- 단점
    - Busy Waiting
        - spin lock이란 만약 다른 스레드가 lock을 소유하고 있다면, 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다.
        - 말그대로 바쁘게 기다리는 Busy Waiting이다. Critical Section에 진입해야 하는 프로세스가 진입코드를 계속 반복해서 실행해야한다.
        - CPU 시간을 낭비하게 된다.
        - 해결방법으로는 Semaphore에서 Ciritical Section에 접근하려다 실패한 프로세스를 Block 시킨 다음에 Ciritical Section에 자리가 났을 때 깨우는 방식을 사용한다.
            - Busy Waiting으로 인한 시간 낭비 문제가 해결된다.






