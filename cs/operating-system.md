# 운영체제

- [프로세스와 스레드](#프로세스와-스레드)
    - [프로그램이란?](#프로그램program이란)
    - [프로세스란?](#프로세스process란)
    - [스레드란?](#스레드란)
- [멀티스레드? 멀티프로세스? 장단점](#멀티-프로세스보다-멀티-스레드)
- [스케줄러](#스케줄러)
    - [장기 스케줄러](#장기-스케줄러)
    - [단기 스케줄러](#단기-스케줄러)
    - [중기 스케줄러](#중기-스케줄러)
- [CPU 스케줄러](#cpu-스케줄러)
    - [FCFS(First Come First Serve)](#fcfsfirst-come-first-serve)
    - [SJF(Shortest-Job-First)](#sjfshortest-job-first)
    - [SRTF(Shortest Remaing Time First)](#srtfshortest-remaing-time-first)
    - [Priority-Scheduling](#priority-scheduling)
    - [Round-Robin](#round-robin-정보처리기사-시험에서-갑자기-기억이-나지-않아서-쓰지-못했던)
- [프로세스 동기화](#프로세스-동기화)
    - [Critical Section Problem](#critical-section)
    - [Critical Section - 임계영역 문제](#critical-section-problem임계-영역문제)
    - [Mutex Lock](#mutex-lock)
    - [Semaphore](#semaphore세마포어)
    - [Deadlock 데드락](#deadlock교착상태)

---

## 프로세스와 스레드

### 프로그램(Program)이란?
- 사전적의미로는 어떤 작업을 위해 실행할 수 있는 파일

### 프로세스(Process)란?
- 사전적의미로는, 컴퓨터에서 연속적으로 실행되고 있는 프로그램
    - **메모리에 올라와서 실행**되고 있는 프로그램의 인스턴스
    - 운영체제로부터 시스템 자원을 할당받는 작업의 단위
    - 동적인 개념에서는 실행중인 프로그램을 의미한다.
- 할당받는 시스템자원에는 무엇이 있나?
    - CPU 시간
    - 운영되기 위해서 필요한 메모리 공간
    - Code, Data, Stack, Heap 구조로 되어있는 독립된 **메모리영역**
- 특징
    - 프로세스는 각각 **독립된 메모리 영역**(Code, Data, Stack, Heap)을 할당받는다.
    - 프로세스당 최소 1개의 스레드(메인스레드)를 가지고 있다.
    - 각 프로세스는 별도의 주소공간에서 실행된다. 다른 프로세스의 데이터에 접근할 수 없다.
    - 다른 프로세스의 자원에 접근하려면 프로세스간 통신(IPC, Inter-Process Communication)을 사용해야한다. 

### 스레드란?
- 프로세스가 할당받은 자원을 이용하는 실행의 단위
- 특징
    - 스레드는 프로세스 영역에서 Stack만 따로 할당받고, Code, Data, Heap영역은 공유한다.
    - 스레드는 한 프로세스 내에서 실행되는 **여러**실행의 흐름으로, 프로세스 내의 주소공간이나 자원들을 같은 프로세스 내의 스레드끼리 공유하면서 실행할 수 있다.
    - 같은 프로세스 안에 있는 스레드들은 힙영역을 공유한다. IPC를 사용하지 않는 이상 프로세스는 다른 프로세스의 자원에 접근할 수 없다는 점을 기억하자.
    - 레지스터와 스택은 별도의 영역을 가진다.
    - 한 프로세스가 프로세스 자원을 변경하면 다른 스레드도 변경된 내용을 읽을 수 있다.
        - 하지만 이 때문에 자원의 동기화문제를 고려해야한다는 단점이 있다.
    
[처음으로](#운영체제)

## 멀티 프로세스보다 멀티 스레드!
멀티 프로세스는 프로그램을 여러개 켜는 것이고, 멀티 스레드는 하나의 프로그램에서 여러 작업을 해결하는 것이다.<br>
멀티 스레드의 장점에 대해서 알아보자
- 자원의 효율성이 증가된다.
    - 멀티 프로세스로 작업하던 작업을 멀티 스레드로 작업할 경우 생성해야하는 프로세스 자원과 시스템콜이 줄어들기 때문에 자원을 효율적으로 관리할 수 있다.
    - 프로세스간의 Context Switching시에 CPU, 레지스터의 교환 뿐만 아니라 RAM과 CPU 사이의 캐시메모리까지 초기화해야하기 때문에 오버헤드가 크기 때문이다.
- 처리비용, 응답시간의 단축
    - 또한 프로세스 간의 통신(IPC)보다 스레드간의 통신의 비용이 싸게 먹히기 때문에 작업들 간의 통신의 부담이 줄어든다.
        - 스레드는 Stack을 제외한 영역의 메모리를 공유하기 때문이다.
    - 프로세스간에 전환하는 속도보다 스레드간에 전환하는 속도가 더 빠르다.
        - Context Switching시에 스레드는 Stack 영역만 처리하기 때문이다.
- 하지만 멀티 스레드를 사용하게 되면 **동기화 문제**를 주의해야한다.
- 스레드간의 자원공유는 전역변수(데이터 세그먼트)를 이용하므로 상용할 때 충돌이 발생할 수도 있다.
- Thread Safe
    - 멀티스레드 환경에서 여러 스레드가 동시에 같은 공유자원에 접근할 때 의도한 대로 동작하는 것을 말한다.
    - Thread Safe 하게 구현하기 위해서는 공유자원에 접근하는 ciritical section을 동기화 기법으로 제어해주어야한다.
    - 동기화 기법으로는 Mutext나 Semaphore가 있다.
    - Reentrant
        - 어떤 함수가 Reentrant하다는 것은 여러스레드가 동시에 접근해도 항상 같은 실행결과를 보장한다는 의미이다.
        - 이를 만족하기 위해서 해당 서브루틴에서 공유자원을 사용하지 않으면 된다.
            - 정적(전역)변수를 사용하거나 반환하지 않고 함수 호출시에 주어진 매개변수만으로 동작하면 된다.
        - Reentrant하다면 Thread-Safe하지만, Thread-Safe하다고 해서 Reentrant한 것은 아니다.

**정리하면**
- 멀티 스레드
    - 장점
        - 멀티 프로세스보다 적은 메모리 공간을 차지한다.
        - Context Switching이 빠르다
    - 단점
        - 오류로 인해서 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 문제점이 있다.
- 멀티 프로세스
    - 장점
        - 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점
    - 단점
        - 멀티스레드보다 많은 메모리 공간과 CPU시간을 차지한다.

대상 시스템에 따라서 적합한 동작방식을 선택해야한다.

[처음으로](#운영체제)

## 스케줄러
프로세스를 스케줄링하기 위한 큐에는 세가지 종류가 존재한다.
- Job Queue: 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue: 현재 메모리 내에 있고, CPU 시간을 할당받기를 기다리는 프로세스의 집합
- Device Queue: Device I/O작업을 대기하고 있는 프로세스의 집합
이러한 각각의 큐에 프로세스들을 넣고 빼주는 스케줄러에도 세가지 종류가 존재한다.

### 장기 스케줄러
> 사용할 수 있는 메모리들은 한정되어 있는데 많은 프로세스들이 한꺼번에 메모리에 올라올 경우, 디스크에 임시로 저장된다. 여기 저장되어 있는 프로세스중 어떤 프로세스를 Ready Queue로 보낼지 결정하는 역할을 한다.

- 메모리와 디스크 사이의 스케줄링을 담당한다.
- 프로세스에 메모리를 할당한다.
- 실행중인 프로세스의 수(degree of Multiprogramming)을 제어한다. <-- 중요!
- 프로세스의 상태는 `new -> ready`

### 단기 스케줄러
> 메모리에 올라와 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정한다.

- 메모리와 CPU사이의 스케줄링을 담당한다.
- Ready Queue에 있는 프로세스 중 어떤 프로세스를 running시킬지 결정한다.
- 프로세스에 CPU를 할당한다.(`scheduler dispatch`)
- 프로세스의 상태는 `ready -> running -> waiting -> ready`

### 중기 스케줄러
- 여유공간의 마련을 위해 프로세스를 통째로 메모리에서 디스크로 좇아낸다(swapping), 다른말로하면 프로세스를 메모리에서 해제(deallocated)시킨다.
- degree of Multiprogramming을 제어하기 위해서 사용한다.
- 현재 시스템에서 메모리에 너무 많은 프로그램이 올라오는 것을 제어하기 위해서 사용한다.
- 프로세스의 상태는 `ready -> suspended`

### 프로세스의 suspended 상태?
- 외부적인 이유로 프로세스의 수행이 정지된 상태. 메모리에서 완전히 내려간 상태를 말한다.
- 메모리에서 디스크로 전부 `swap out`된다.
- blocked된 상태는 Device I/O작업을 기다리는 상태이기 때문에 스스로 ready 상태로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending되었기 때문에 스스로 돌아갈 수 없다.

[처음으로](#운영체제)

## CPU 스케줄러

스케줄러에서 스케줄링할 대상은 Ready Queue에 있는 프로세스를 대상으로 한다.
### FCFS(First Come First Serve)
- 먼저온 작업을 먼저 처리해주는 방식이다.
- `Non-preemptive` 스케줄링
    - CPU를 잡으면 작업이 완료될 때까지 CPU를 반환하지 않는다. 할당되었던 CPU가 반환될 때만 스케줄링이 이루어진다.
- 소요시간이 긴 프로세스가 먼저 도달하게 되면 효율성이 낮아진다.

### SJF(Shortest-Job-First)
- 다른 프로세스가 먼저 도착했어도 CPU사용시간이 짦은 프로세스에게 CPU가 먼저 할당된다.
- `Non-preemptive` 스케줄링 방식이다.
- `starvation`
    - 효율성을 추구하는 것이 가장 중요하긴 하지만, 수행시간이 긴 프로세스가 영원히 CPU를 할당받지 못할수도 있다.

### SRTF(Shortest Remaing Time First)
- `SJF`의 preemtive한 버전이라고 생각하면 편하다.
- 새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어진다.
- 선점형(`Preemptive`) 스케줄링
    - 현재 수행중인 프로세스의 남은 CPU 타임보다 더 짧은 CPU 타임을 가지는 프로세스가 도착하면 더 짧은 프로세스에게 CPU를 넘겨주는 스케줄링 방식이다.
- `starvation`
    - `SJF`와 동일하게 `starvation`문제가 있다.

### Priority-Scheduling
- `SJF`나 `SRTF`에서는 시간 짧게 걸리는 작업이 높은 우선순위를 가지고 처리되었다. 하지만 우선순위가 낮은 프로세스는 계속해서 뒤로 밀려서 CPU를 할당받지 못할수도 있는데, 이를 `starvation`이라고 한다.
- 우선순위가 가장 높은 프로세스에게 CPU를 할당하는 스케줄링을 말한다.
- Preemptive Scheduling
    - 더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU를 선점한다.
- Non-Premmptive Scheduling
    - 더 높은 우선순위의 프로세스가 도작하면 Ready Queue의 Head에 넣는다.
- 우선순위가 낮은 프로세스는 계속해서 뒤로 밀려서 CPU를 할당받지 못하는, `starvation`문제가 발생할 수 있다.
- 우선순위가 낮았던 프로세스라도 오래 기다리면 높은 우선순위를 주는 `aging`이라는 방법을 사용해서 해결한다.

### Round-Robin (~~정보처리기사 시험에서 갑자기 기억이 나지 않아서 쓰지 못했던~~)
- interactive한 작업을 할 때 현대에 보편적으로 사용할 수 있는 방법이다.
- 각 프로세스가 동일한 크기의 할당시간(time quantum)을 가지게 된다.
- 할당시간이 지나면 CPU가 다른 프로세스에게 선점당하고 ready queue의 가장 뒤에가서 다시 줄을 선다
- CPU사용시간이 랜덤한 프로세스들이 섞여있을 때 효율적이다.
- 프로세스의 context를 save할 수 있기 때문에 가능한 방식이다.
- 응답이 빠르다는 장점이 있지만, context switching이 자주 일어나는만큼 오버헤드가 많이 소모된다는 단점이 있다.

> ⚠️ 주의점<br>
> `time quantum`이 너무길어지면 `FCFS` 알고리즘과 다를바 없어진다.<br>
> `time quantum`이 너무 짧으면 context switching이 그만큼 자주일어나 오버헤드가 많이 소모된다.<br>
> 따라서 적절한 수준의 `time quantum`을 찾는 것이 중요하다.

[처음으로](#운영체제)

## 프로세스 동기화
### `Critical Section`
- 앞의 멀티스레딩의 문제점에서도 보았듯이, 동일한 자원에 동시에 접근하는 작업을 실행하는 **코드 영역**을 `Critical Section`이라 부른다.

### Critical Section Problem(임계 영역문제)
- 프로세스들이 `Critical Section`을 함께 사용할 수 있는 프로토콜을 설계해야한다.
- 해결을 위한 기본 조건
    - Mutual Exclusive(상호 배제)
        - 하나의 프로세스가 `Critical Section` 내부에서 시행중이라면, 다른 프로세스들은 그들이 거쳐야하는 `Critical Section`에서 실행될 수 없다.
    - Progress(진행)
        - `Ciritical Section`에서 실행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 `Ciritcal Section`의 진입 후보가 될 수 있다.
    - Bounded Waiting(한정된 대기)
        - 어떤 프로세스가 `Ciritical Section`에 진입 신청 후부터 받아들여질 때까지, 다른 프로세스들이 `Ciritical Section`에 진입하는 횟수는 제한이 있어야한다.

### 동기화 문제 해결책
### Mutex Lock
- 공유자원에 동시에 접근하는 것을 막기 위해서 Ciritical Section에 진입하는 프로세스가 Lock을 획득하고, 나올때 Lock을 방출해서 동시에 접근되지 않도록 하는 방법이다.
- 하지만 다중 처리기 환경에서는 시간적인 효율성 측면에서 적용할 수 없다.
### Semaphore(세마포어)
- Mutex Lock과 마찬가지고 Critical Section에 접근하는 문제를 해결하기 위해서 만든 동기화 도구이다.
- 세마포어에는 Counting/Binary Semaphore 추가지 종류가 있다.
    - 카운팅 세마포어(Counting Semaphore)
        - 세마포어의 개수만큼 스레드가 자원에 접근할 수 있다.
        - 당연히 자원에 접근할 수 있는 수만큼 세마포어 값이 초기화된다.
        - 자원을 사용하면 세마포어가 감소, 방출하면 세마포어가 증가한다.
    - 이진 세마포어(Binary Semaphore)
        - MUTEX라고도 부르며, 상호배제의(Mutext Exclusive)의 머릿글자를 따서 만들어졌다.
        - 이름처럼 0과 1사이의 값만 가능하다. 다중 프로세스들 사이의 Critical Section 문제를 해결하기 위해서 사용한다.
- 단점
    - Busy Waiting
        - spin lock이란 만약 다른 스레드가 lock을 소유하고 있다면, 그 lock이 반환될 때까지 계속 확인하며 기다리는 것이다.
        - 말 그대로 바쁘게 기다리는 Busy Waiting이다. Critical Section에 진입해야 하는 프로세스가 진입코드를 계속 반복해서 실행해야한다.
        - CPU 시간을 낭비하게 된다.
        - 해결방법으로는 Semaphore에서 Ciritical Section에 접근하려다 실패한 프로세스를 Block 시킨 다음에 Ciritical Section에 자리가 났을 때 깨우는 방식을 사용한다.
            - Busy Waiting으로 인한 시간 낭비 문제가 해결된다.
### Deadlock(교착상태)
    - 세마포어가 Ready Queue를 가지고 있고, 둘 이상의 프로세스가 Critical Section의 진입을 무한정 기다리고 있고, Ciritical Section에서 실행되는 프로세스는 진입 대기중인 프로세스가 실행되어야만 빠져나올 수 있는 상황을 지칭한다.

[처음으로](#운영체제)






