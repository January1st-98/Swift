# 코어데이터

`되새김`어플을 만들면서도 코어데이터를 사용했지만 깊은 학습없이 엔티티를 만들고.. fetch해오고의 반복이였던 것 같다. 이번에는 내부 동작까지 어떻게 이루어지는지 공부하면서 코어데이터란 무엇이고 어떻게 이루어져있고, 어떤특징이 있으며 어떤 기능을 지원하는지에 대해 알아보자.

## 코어데이터란?
코어데이터란 `객체지향 데이터베이스`를 위한 `객체 그래프 관리`프레임워크이다. 단순히 배열이나 리스트가 아닌 체계적인 데이터베이스를 관리해야할 때 필요하다. 주의해야할 점은 **밖에서 보기에는 객체지향 데이터베이스이지만 내부는 관계형 데이터베이스(Relational Database)라는 점**이다. 주로 처리하는 건 관계형 데이터베이스 중에서 SQL기반이다. 하지만 사용하는 입장에서 SQL을 직접 사용할 필요는 없다.

## 그렇다면 코어데이터 == 데이터베이스 인가?
코어데이터는 관계형 데이터베이스라고 했다. 이런말만듣고 또 사용하다보면 코어데이터가 데이터베이스인가? 착각할 수 있지만 이는 올바른 이해가 아니다. 정확히 하면 코어데이터는 데이터베이스가 아니고 코어데이터의 기능 중 하나인 **Persistence**가 관계형 데이터베이스인 SQLite에 의해 지원되는 것이다. 이 말은 곧 데이터베이스의 기능을 코어데이터가 지원하기도 하고 SQLite에 없는 코어데이터의 고유기능을 가지고 있기도 하다는 의미이다.

**코어데이터는 애플리케이션 모델 계층의 객체를 관리하는데 사용하는 `프레임워크` 이자 객체의 라이프 사이클이나 영속성관리를 위한 기능을 제공하는 `객체 그래프 관리자` 이다.**

**`객체 그래프 관리자`** 라는 단어에서 알 수 있듯이 외부에서 보기에는 객체지향 데이터베이스의 형태를 띄고 있지만 그 내부에는 SQLite 데이터베이스 처럼 기능하고 있다.

## 코어데이터 vs 데이터베이스
먼저 데이터베이스의 주된기능에 대해서 생각해보자. 데이터베이스는 **영속적이고 검색 가능한 테이블 구조의 행/열로 구성된 데이터 저장소**라고 생각할 수 있다. 이 저장소의 목적은 **디스크에 항상 최신의 데이터를 저장하는 것과 데이터를 불러오고 업데이트 하는 것**이다. 많은 데이터베이스들이 관계형이라고 불리지만 SQLite와 많은 다른 관계형 데이터베이스들은 실제로 객체들의 직접적 연결을 다루지는 않는다. 테이블 간의 행/열에 관한 관계를 유지하는 것은 데이터베이스를 사용하는 사용자가 해야한다. 이러한 관점에서 데이터베이스는 `멍청한(dumb)`저장소이다. 테이블의 열을 다룰 경우 읽기/쓰기 이상의 동작이 거의 전부이고 이를 확장하거나 커스터마이징 하기 위해서는 결국 데이터베이스 시스템 전체를 확장할 수 밖에 없다.

그렇다면 `코어데이터`의 주된기능은 무엇일까? 코어데이터의 본질은 라이프사이클, 검색, 영속성 기능을 가진 객체 그래프 관리자(object graph manager)이다. 객체그래프 관리는 아래 기능들을 의미한다.
- 객체 A와 객체 B를 연결할 수 있으며, 해당 연결은 영속적으로 동기화 한다.(A쪽에서 연결을 변경하면, B가 업데이트 되면서 그에따른 알림(notification)을 발생시킨다. 그리고 이 알림에대해 임의로 코드를 짜넣어서 실행하는 것이 가능하다.)
- 한쪽에서 객체를 삭제할 경우 연결을 타고 `cascade`하게 삭제가 일어나도록 할 수도 있고, `nullify`시켜서 해당 객체만 삭제할 수도 있다.

보통의 데이터베이스와는 다르게 코어데이터는 완전한 `in-memory`형태로 사용이 가능하다. 일반적으로 사용자들이 영속성 특성을 대부분 사용하기 때문에 코어데이터가 `객체 영속성`프레임워크라고 불리지만 실제로는 어떠한 형태의 영속성도 지니지 않은 `in-memory`형태로 사용하는 것이 가능한 것이다. 즉 코어데이터를 사용할 때 `영속성`이 의무적인 기능이 아니란 것을 아는 것이 중요하다.

또한 코어데이터를 어떠한 형태의 검색기능 없이도 사용가능하다. 일단 객체들이 할당되고 연결되었을 경우, 한 객체에만 접근이 가능하다면, 추가적인 불러오기(fetch)없이 해당객체로부터 나머지 연결된 객체들을 타고 넘어가면서 접근이 가능하다. 일단 데이터들이 메모리에 로딩되면, 연결고리를 따라 이동하는 것은 검색 없이도 가능하기 때문에 코어데이터가 이러한 `비검색(searchless)`특성을 가지게 된다. 

모든 코어데이터 객체들은 완전히 인스턴스화된(fully instantiated) Objective-C객체이며 속성값과, 관계, 라이프사이클을 관리하는 것이 가능하다. 이것은 또한 객체들의 속성들과 동작들이 메서드에의해 구현될 수 있음을 의미하며, 이러한 메서드들은 서브클래싱을 통해 옵저브와 오버라이드가 가능하다.(observable & overriding)

## CoreData와 UserDefaults
### UserDefaults
- 데이터를 key-value로 저장하는 가장 쉬운 방법
- 적은 양의 데이터를 저장하기에 매우 적합하다.
- user setting, user's preferences와 같은 중요하지 않은 정보를 저장하는데 사용한다.
- **암호화되어 저장되는 스토리지가 아니기때문에** 중요하지 않은 정보면 저장하도록 권장하고 있다.
- 앱 시작과 함께 **요청하지도 않은 정보에 대해서도 모두 메모리에 로드**하기 때문에 큰 양의데이터를 저장하기에 적합하지 않다.
### CoreData
- SQLite 데이터베이스 기반으로 객체지향, 관계형 데이터베이스를 제공한다.
- on-disk, in-memory등 저장방식을 선택할 수 있다.
- 많은 양의 데이터베이스를 객체그래프 형태로 관리하기에 용이하다.
- UserDefaults와는 다르게 필요한 정보에 대해서만 fetch해온다.
- 러닝커브가 높고 오버헤드의 발생이 단점이다.

## 객체 그래프 관리자가 그래서 뭐야?
위에서 몇번이나 **`객체 그래프 관리자(Object Graph Manager)`** 라는 단어가 나왔다. 아래 사진을 보면 왜 객체 그래프라는 용어가 나왔는지 알 수 있다. **메모리에 객체들이 여러 relationship으로 엮여있는 것을 객체그래프**라고 하고, 이 형태를 그대로 코어데이터의 컨테이너에 저장시키기 때문이다.

## 데이터베이스 vs 객체 그래프 관리
데이터베이스와 코어데이터의 객체 그래프 관리자 기능은 완전히 배타적인 관계는 아니다. SQLite에서는 기본적으로 외래키(foreign key)가 지원되지 않지만, MySQL 등의 다른 데이터베이스 들은 여러 테이블들에 대해 identifier들을 관리하여 관계가 설정된 레코드들간의 싱크를 맞출 수 있으며 심지어 cascade 삭제 또한 가능하다. 즉 오버라이드 가능한 객체들을 이용하여 코드를 작성하는 커스터마이제이션은 불가능하지만 기본적인 수준의 관계 관리는 가능하다는 의미이다.

코어데이터의 모델과 비슷한 다른 객체 관계 프레임워크들이 존재하긴 하지만 대부분 원자성(atmomicity)을 보장하며, 트랜잭션(transaction)기반의 데이터베이스들이다. 이런 프레임워크들이 객체 그래프를 업데이트 하기 위해서는 다음과 같은 절차를 따른다.

- 데이터베이스로부터 적절한 레코드 행(row)을 불러온다
- 이러한 레코드들로부터 객체 인스턴스를 생성한다
- 인스턴스화되어 메모리상에 존재하는 그래프 객체들을 수정한다
- 수정된 내용들을 다시 데이터베이스에 반영(commit) 한다.

원자성을 보장하기 위해서는 위의 4가지 절차가 하나의 트랜잭션으로 수행되어야 한다. (즉, 트랜잭션이 진행중일때는 다른 읽기/쓰기 작업이 레코드에 영향을 주면 안된다.) 이러한 원자성 보장이 요구되는 시스템들도 있긴하지만, 이 방법은 일반적인 객체 그래프 시스템에 대해 적용할 경우 많이 느릴수밖에 없다.

따라서 더 일반적인 **객체 관리 시스템을 위해 설계된 코어데이터는 더 나은 성능과 유연성을 위해 이 모델을 따르지 않는다.**

<p align="center">
<img width="600" src="https://user-images.githubusercontent.com/76734067/210105149-e4fbef94-7934-4718-b056-c21ea047d571.png">
</p>

중간의 `context`라는 것은 아래에서 설명하도록 하겠다. 지금은 트랜잭션의 역할을 하는 것이라고 알아두자. 일단 코어데이터가 위와같은 단계를 거쳐 객체그래프를 관리한다고 알아두자.

## 코어데이터의 구성

<p align="center">
<img width="50%" src="https://user-images.githubusercontent.com/76734067/210131730-67dd4c61-73b7-4b6e-83a2-2201f359504a.png">
</p>

그렇다면 코어데이터는 무엇이며, 데이터베이스와 어떻게 다르고 어떤 기능적지원을 하는지 알아보았다. 그렇다면 실제로 코어데이터를 활용하기 위해 어떤 요소들로 이루어져있는지 살펴보자

<p align="center">
<img width="70%" src="https://user-images.githubusercontent.com/76734067/210131788-caa72de1-ddf3-4ecc-a98a-8fab7b80b6be.png">
</p>

### 관리객체(Managed Object): `NSManagedObject`
- 데이터베이스 안에 있는 것들의 타입이 `NSManagedObject`로 테이블에서 레코드를 읽을 때 코어데이터에서는 객체가 생성되는데, 이 객체를 저장하는 자료형이다.<br>
    ex) 직원들의 데이터를 다룰 때 DB에서 직원들의 정보를 읽어오면 이것을 그대로 상요하지 않고 VO(Value Object)인스턴스에 담아서 사용한다. 이때 VO가 Managed Object에 해당한다.

### 관리 객체 컨텍스트(Managed Object Context): `NSManagedObjectContext`
- `NSManagedOjbectContext`는 데이터베이스를 대표하며 모든 코어데이터 활동이 이루어지는 허브와 같은 곳이다. 그리고 코드로 context에 접근하기 위해서 `NSPersistentContainer`가 필요하다.
- 컨텍스트의 핵심적인 역할
    1. Managed Object를 가지고 CRUD역할(Core Data에서 생성되는 모든 관리 객체는 컨텍스트에 담겨 관리)
        - 컨텍스트에 담긴 객체는 영구 저장소로 보내 저장, 삭제 가능
        - 코어 데이터는 메모리에 로드된 상태로 처리되는데, 이 때의 메모리가 컨텍스트를 의미
    2. **`영구저장소`** 와 **`영구 저장소 코디네이터`** 에 대한 관리자 역할
        - 읽기와 쓰기를 영구저장소에 요청한다.(DAO 패턴과 유사)

`viewContext`는 `NSManagedObjectContext` 중에서도 메인 스레드에서만 사용할 수 있는 변수이다. 메인큐에서만 사용되는 이 변수의 이름이 `viewContext`인 이유는 UIView와 함께 사용되기 때문이다. 메인큐에서만 사용한다는 것이 중요한 것은 `NSManagedObjectContext`가 thread safe하지 않기 때문이다. 코어데이터의 스레드 안전성에 대해서는 아래에서 다루겠다.

### 영구 저장소 코디네이터(Persistent Store Coordinator)
- 컨텍스트와 직접 데이터를 주고받으면서 다양한 영구저장소들의 접근을 조정하고 입출력을 담당한다.
    1. 컨텍스트가 데이터를 요청
    2. 코디네이터가 요청을 받고 영구저장소에서 데이터 탐색
    3. 코디네이터가 Managed Object인스턴스를 생성하여 반환

### 관리 객체 모델(Managed Object Model)
- 엔티티(Entity)의 구조를 정의하는 객체인 동시에 이를 바탕으로 Managed Object패턴의 모델 클래스를 참조
- Managed Object Model vs Managed Object
    - Managed Object Model: 클래스이자 형식이고 구조를 의미한다. 데이터를 CRUD하지 않으며 관리 객체의 각 요소를 제대로 담을 수 있도록 저장데이터를 구조화한다.
    - Managed Object: Managed Object Model을 바탕으로 생성된 인스턴스

### 영구 객체 저장소 (Persistent Object Store)
초기에는 직접 읽을 수 있으며 디버깅에 용이한 XML 저장소 타입을 사용하며, 앱을 배포할 당시 대량의 데이터를 고려하여 SQLite데이터베이스를 사용하는 것이 용이하다.

## 코어데이터와 Thread Safe
코어데이터의 스레드안전성에 대해 알아보자. 데이터베이스에서 다루어지는 모든 것들은 Thread Safe하지 않다. context는 자신한테 생성된 큐에서만 생성될 수 있다. 만약 context를 다른 큐에 넘기게 되면 작동하지 않을 것이다. context뿐 아니라 해당context에서 생성한 모든 데이터도 동일한 큐에서 처리되어야 한다. 일반적으로 코어데이터도 빠르지만 데이터를 로드해오는 것은 메인에서 하지 않는 것이 좋다.

이를 위해서 데이터베이스가 멀티스레드로 작동하도록 할 수 있다. 각각의 데이터베이스가 여러 context를 가질 수 있는데 완전히 다른 context는 각각 다른 큐에 있더라도 동일한 데이터베이스에 기록할 수 있다. 그렇다면 어떻게 context를 여러 큐에 넣을 수 있을까?

`performBlock`메서드는 정의된 클로저가 올바른 큐에서 작동한다는 것을 보장해주는 메서드이다. 여러 큐에 여러 context를 넣기 위해서는 이 메서드를 사용해주어야 스레드 안전성을 지킬 수 있을 것이다. 하지만 다른 스레드에 있는 context를 가져오는 것은 어떻게 할 수 있을까? 이방법으로는 해결할 수 없는 문제이다.

`persistentContainer`에는 `performBackgroundTask`라는 코어데이터에서 백그라운드 작업을 할 수 있도록 하는 메서드가 있다. 이 메서드는 메인큐가 아닌 다른 큐를 찾아 context를 생성하고 클로저에 있는 내용을 수행하도록 한다. 이때 클로저 내부에서는 절대로 `viewContext`를 사용해서는 안된다. 이 클로저는 메인큐에서 돌아가지 않는데 `viewContext`는 메인큐에서 사용되기 때문이다. 그리고 반드시 저장해야한다. 이렇게 백그라운드 스레드에서 실행될 클로저에서도 저장하고 나면 `viewContext`에서도 동일한 데이터베이스의 업데이트 사항에 대해 올바르게 접근하게 된다.

## 한계

코어데이터는 데이터베이스가 아니라고 했는데, 데이터베이스에서는 할 수 있지만 코어데이터가 하지 못하는 작업에 대해 생각해볼 수 있다.

### 코어데이터는 데이터들을 메모리에 로딩하는 과정 없이는 작업할 수 없다.

SQL구문에서 테이블을 삭제하거나 레코드들을 업데이트하기 위해서 `DROP tableName` 이나 `UPDATE tableName SET key1 = value WHERE key2 = otherValue` 명령이 이용된다. 명령 처리를 위해서 각 레코드에 해당하는 작은 크기의 데이터만 메모리에 로드를 하면 되기때문에, 데이터의 양이 많더라도 효율적으로 업데이트가 가능하다. 하지만 **코어데이터는 메모리상의 객체를 수정하는것만이 가능하기 때문에 이러한 온디스크(on-disk) 방식의 사용이 불가능**하다. 심지어 **코어데이터는 객체를 삭제 할 때도, 일단 인스턴스화 시켜서 메모리에 로드를 먼저 해야 삭제가 가능**하다. 객체에 추가적으로 오버라이드된 동작들이 로드되고 실행되기 위해서, 그리고 다른 객체와의 연결정보를 최신으로 유지하기 위해서는 이러한 메모리 로드작업이 필수적일 수밖에 없다.

따라서 코어데이터에서 많은 수의 객체들(수만개 혹은 그 이상)을 수정할 경우 다음과 같은 방법들을 사용하여 메모리 사용량(memory footprint)을 최소한으로 유지할 필요가있다.

- `refreshObject:mergeChanges:`메서드를 이용하여 주기적으로 변하지 않은 객체들을 해제
- `NSFetchRequest`사용시 `setIncludesPropertyValues:NO` 설정을 이용하여 객체의 전체데이터를 불러오는 것을 피하기
- 전체 컨텍스트를 저장한 후, 로드되어 있던 모든 객체들을 릴리즈

### 코어데이터는 데이터 로직을 다루지는 않는다.

SQL에 존재하는 저장되는 데이터를 제약할 수 있는 unique key 같은 기능이 코어데이터에는 포함되어있지 않다. 코어데이터로부터 생성된 모델클래스를 상속받아서 사용할경우, 코어데이터의 attribute에대해 getter/setter를 오버라이드 할 수 있다보니 코어데이터 입장에서는 이것이 unique key 인지 아닌지 알 수가 없다. 결국 이러한 제약조건들이 코어데이터에서 제어가능한 도메인 밖에 있다보니 모델에 적용하려면 애플리케이션 레벨에서 직접 비지니스 로직상에서 따로 구현해야 한다.

