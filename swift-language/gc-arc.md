# 가비지 컬렉터(GC)와 자동참조카운트(ARC)

각 언어마다 메모리를 관리하는 방법이 있고 자바는 GC, Swift는 ARC메모리 관리 모델을 사용한다.
ARC와 GC는 어떻게 다르고 애플의 Swift는 왜 ARC모델을 선택했는지 궁금해졌다. 

## GC
- 메모리 관리를 Garbage Collector(가비지 컬렉터)가 해준다.
- 프로그램 실행중에 객체들을 동적으로 감시하고 있다가 **더이상 쓸모없다고 판단되는 객체를 메모리에서 해제해준다.**
- `런타임`에 메모리 관리는 한다는 것이 중요하다.

## ARC
- ARC는 말그대로 어떤 객체가 얼마나 참조되고 있는지를 Reference Count를 세는 것이고, 이 값이 0이 될때 메모리에서 해제된다.
- GC와는 다르게 런타임에 실행되는 것이 아니라 코드를 빌드하는 `컴파일타임`에 코드 중간중간에 `retain`, `release`를 적절한 곳에 넣어주는 개념이다.
- Swift 코드를 작성하는 개발자가 직접 명령들을 작성할 필요없이 알아서 작성해주는 것이다.

## GC와 ARC 무슨 차이가 있나?
- 위에서 보았듯이 첫번째로 GC는 런타임에, ARC는 컴파일타임이라는 시점의 차이가 있다.
- GC는 런타임에 실행되고 있기 때문에 항상 메모리를 차지하고 있으므로 프로그램 자체의 메모리 사용량이 더 늘어날 수밖에 없고, CPU도 일부 사용해야만한다.
- ARC는 수동으로 개발자가 넣어야되는 코드를 컴파일 타임에 자동으로 넣어주는 것이기 때문에 그러한 오버헤드에서 자유롭다.
- 리소스(메모리, CPU)가 더 제한적인 모바일 기기에서 이런 성능측면에서는 ARC가 당연히 더 이득이다.

지금까지 언급한 내용을 정리해보면 다음과 같다.

|구분|`GC`|`ARC`|
|:-:|:-|:-|
|참조 계산 시점|**런타임**, 주기적으로 참조를 추적하여 사용하지 않는 인스턴스를 해제한다.|**컴파일 타임**에 언제 참조되고 해제될지가 결정된다.|
|장점|인스턴스가 해제될 확률이 RC에 비해 높다|개발자가 참조 해제 시점을 파악할 수 있다.<br>런타임에 추가적인 오버헤드가 발생하지 않는다.|
|단점|개발자가 참조 해제 시점을 파악할 수 없다.<br>런타임시점에 객체를 추적하는 오버헤드로 성능저하가 있을 수 있다.|순환참조 발생 시 영구적으로 메모리가 해제되지 않는 메모리누수의 위험이 있다.|

## GC가 순환참조를 해결할 수 있나요?
- ARC방식의 경우에는 retain cycle문제가 발생할 경우 해결할 수 없고 메모리 누수가 발생하게 된다. `weak`, `unowned`등 키워드를 사용해서 개발자가 사전에 방지해주어야 한다.
- GC의 경우에는 결론부터 말하면 **순환참조를 해결할 수 있다.**
    - GC는 Mark and Sweep프로세스를 통해서 메모리에서 필요없는 부분을 해제한다.
    <img width="813" alt="image" src="https://user-images.githubusercontent.com/76734067/209575777-894e7c34-b7be-4dda-85ae-f68cd34a08d4.png">
    - 가비지 컬렉터에는 GC root라는 가비지 컬렉션의 root역할을 하는 오브젝트가 있다.
    - Sweep이란?
        - 루트에서 시작하여 참조로 연결된 오브젝트들을 마크(mark)한다.
        - 마크가 끝나면 힙내부 전체를 돌면서 마크되지 않은 오브젝트들을 모두 해제(reclaim)한다.
        - 이 일련의 과정들을 Sweep이라 한다.
    - 루트로부터 닿을 수 있는 노드들은 살려두고 나머지 오브젝트는 메모리에서 해제하는 것이다.
    - 순환참조가 메모리 누수라는 결과로 이어지는 이유는, 오브젝트들을 참조하는 외부참조를 사라지게 했음에도 오브젝트끼리 서로 참조하고 있기 때문에 메모리에서 해제되는 것이다. 외부참조가 사라졌다는 것이 GC root로부터 닿을 수 없다는 것을 의미하게 되므로 순환참조가 발생해도 메모리 누수로 이어지지 않게 되는 것이다.
